package mgo

import "gopkg.in/mgo.v2"

// NewPipe creates an instance of IPipe with the given *mgo.Pipe if passed as an arg.
// Note: The IPipe instance returned will not work without a valid *mgo.Pipe.
func NewPipe(p ...*mgo.Pipe) IPipe {
	if len(p) > 0 {
		return &pipe{Pipe: p[0]}
	}
	return &pipe{}
}

// IPipe is an interface which matches the contract for the `Pipe` struct in `gopkg.in/mgo.v2` package. The function documentation has been narrowed from the original
// in `gopkg.in/mgo.v2`. For additional documentation, please refer to the `mgo.collection` in the `gopkg.in/mgo.v2` package.
type IPipe interface {
	// Iter executes the pipeline and returns an iterator capable of going over all the generated results.
	Iter() IIter
	// All works like Iter.All.
	All(result interface{}) error
	// One executes the pipeline and unmarshals the first item from the result set into the result parameter.
	// It returns ErrNotFound if no items are generated by the pipeline.
	One(result interface{}) error
	// Explain returns a number of details about how the MongoDB server would execute the requested pipeline, such as the
	// number of objects examined, the number of times the read lock was yielded to allow writes to go in, and so on.
	//     - See the Tail documentation in `gopkg.in/mgo.v2` for more information.
	Explain(result interface{}) error
	// AllowDiskUse enables writing to the "<dbpath>/_tmp" server directory so
	// that aggregation pipelines do not have to be held entirely in memory.
	AllowDiskUse() IPipe
	// Batch sets the batch size used when fetching documents from the database. It's possible to change this setting on a
	// per-session basis as well, using the Batch method of Session.
	//     - See the Tail documentation in `gopkg.in/mgo.v2` for more information.
	Batch(n int) IPipe
	// P returns the internal mgo.pipe used by this implementation.
	P() *mgo.Pipe
}

type pipe struct {
	*mgo.Pipe
}

func (p *pipe) P() *mgo.Pipe {
	return p.Pipe
}

func (p *pipe) Iter() IIter {
	return p.Iter()
}

func (p *pipe) AllowDiskUse() IPipe {
	return p.update(p.P().AllowDiskUse())
}

func (p *pipe) Batch(n int) IPipe {
	return p.update(p.P().Batch(n))
}

func (p *pipe) update(pipe *mgo.Pipe) IPipe {
	p.Pipe = pipe
	return p
}

func fromPipe(p *mgo.Pipe) IPipe {
	if p == nil {
		return nil
	}
	return &pipe{Pipe: p}
}
